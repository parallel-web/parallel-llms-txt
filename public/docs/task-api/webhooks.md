# Webhooks

> Webhook events for task run completions

<Note>
  {" "}

  This feature is currently in beta and requires the <code>
  parallel-beta: webhook-2025-08-12
  </code> header when using the Task API.{" "}
</Note>

## Overview

Webhooks allow you to receive real-time notifications when your Parallel Task Runs complete, eliminating the need for constant polling—especially for long-running or research-intensive tasks.
Our webhooks follow [standard webhook conventions](https://github.com/standard-webhooks/standard-webhooks/blob/main/spec/standard-webhooks.md) to ensure security and interoperability.
You can view and manage the secret keys used to sign webhook calls in <strong>Settings → Webhooks</strong>.

## Setup

### 1. Record your webhook secret

Go to <strong>Settings → Webhooks</strong> to view your account webhook secret.

### 2. Configure Webhook in Task Run Request

To register a webhook for a task run, include a webhook parameter in your task run
creation request:

<CodeGroup>
  ```bash cURL theme={"system"}
  curl --request POST \
    --url https://api.parallel.ai/v1/tasks/runs \
    --header "Content-Type: application/json" \
    --header "parallel-beta: webhook-2025-08-12" \
    --header "x-api-key: PARALLEL_API_KEY" \
    --data '{
      "task_spec": {
        "output_schema": "Find the GDP of the specified country and year"
      },
      "input": "France (2023)",
      "processor": "core",
      "metadata": {
        "key": "value"
      },
      "webhook": {
        "url": "https://your-domain.com/webhooks/parallel",
        "event_types": ["task_run.status"]
      }
    }'
  ```

  ```typescript TypeScript (SDK) theme={"system"}
  import Parallel from "parallel-web";

  const client = new Parallel({
    apiKey: process.env["PARALLEL_API_KEY"],
  });

  const taskRun = await client.beta.taskRun.create({
    task_spec: {
      output_schema: "Find the GDP of the specified country and year",
    },
    input: "France (2023)",
    processor: "core",
    metadata: {
      key: "value",
    },
    webhook: {
      url: "https://your-domain.com/webhooks/parallel",
      event_types: ["task_run.status"],
    },
    betas: ["webhook-2025-08-12"],
  });

  console.log(taskRun.run_id);
  ```

  ```python Python theme={"system"}
  import requests

  url = "https://api.parallel.ai/v1/tasks/runs"
  headers = {
      "Content-Type": "application/json",
      "x-api-key": "PARALLEL_API_KEY",
      "parallel-beta": "webhook-2025-08-12",
  }

  payload = {
      "task_spec": {
          "output_schema": "Find the GDP of the specified country and year"
      },
      "input": "France (2023)",
      "processor": "core",
      "metadata": {
          "key": "value"
      },
      "webhook": {
          "url": "https://your-domain.com/webhooks/parallel",
          "event_types": ["task_run.status"],
      }
  }

  response = requests.post(url, json=payload, headers=headers)
  print(response.json())
  ```
</CodeGroup>

### Webhook Parameters

| Parameter     | Type           | Required | Description                                        |
| ------------- | -------------- | -------- | -------------------------------------------------- |
| `url`         | string         | Yes      | Your webhook endpoint URL. Can be any domain.      |
| `event_types` | array\[string] | Yes      | Currently only `["task_run.status"]` is supported. |

Use <strong>Settings → Webhooks</strong> to view or rotate your account webhook secret.

## Webhook Events

### Task Run Status

We currently support `task_run.status` event on task run completions.

When a task run finishes, either with a success or a failure, we will send a
`POST` request to your configured webhook endpoint.

## Response Format

### Request Headers

Your webhook endpoint will receive requests with these headers:

* `webhook-id`: Unique identifier for each webhook event
* `webhook-timestamp`: Unix timestamp in seconds
* `webhook-signature`: One or more versioned signatures, e.g. `v1,<base64 signature> v1,<base64 signature>`

```json  theme={"system"}
{
  "Content-Type": "application/json",
  "webhook-id": "whevent_abc123def456",
  "webhook-timestamp": "1751498975",
  "webhook-signature": "v1,K5oZfzN95Z9UVu1EsfQmfVNQhnkZ2pj9o9NDN/H/pI4="
}
```

Signatures are space-delimited per the Standard Webhooks format. The `webhook-signature`
header can include multiple entries separated by spaces; you should check each entry
until you find one which matches the signature generated by your webhook secret.

Under normal circumstances there will only be one signature in the `webhook-signature`
header, but there may be multiple if you rotate your webhook secret without immediately
expiring the old secrets.

```text  theme={"system"}
webhook-signature: v1,BASE64SIG_A v1,BASE64SIG_B
```

### Webhook Payload Structure

Each webhook payload contains the following fields:

* `timestamp`: ISO 8601 timestamp of when the event occurred
* `type`: Event type (currently only `task_run.status` is supported)
* `data`: Event-specific payload. For the 'task\_run.status' event, it is the complete [Task Run object](https://docs.parallel.ai/api-reference/task-api-v1/retrieve-task-run)

#### Example Payloads

The following examples demonstrate the payload structure for completed and failed task runs:

```json Success theme={"system"}
{
  "timestamp": "2025-04-23T20:21:48.037943Z",
  "type": "task_run.status",
  "data": {
    "run_id": "trun_9907962f83aa4d9d98fd7f4bf745d654",
    "status": "completed",
    "is_active": false,
    "warnings": null,
    "error": null,
    "processor": "core",
    "metadata": {
      "key": "value"
    },
    "created_at": "2025-04-23T20:21:48.037943Z",
    "modified_at": "2025-04-23T20:21:48.037943Z"
  }
}
```

```json Failure theme={"system"}
{
  "timestamp": "2025-04-23T20:21:48.037943Z",
  "type": "task_run.status",
  "data": {
    "run_id": "trun_9907962f83aa4d9d98fd7f4bf745d654",
    "status": "failed",
    "is_active": false,
    "warnings": null,
    "error": {
      "message": "Task execution failed",
      "details": "Additional error details"
    },
    "processor": "core",
    "metadata": {
      "key": "value"
    },
    "created_at": "2025-04-23T20:21:48.037943Z",
    "modified_at": "2025-04-23T20:21:48.037943Z"
  }
}
```

## Security & Reliability

### HMAC Signature Verification

Webhook requests are signed using HMAC-SHA256 with **standard Base64 (RFC 4648) encoding with padding**. The signature header is formatted as `v1,<base64 signature>` where `<base64 signature>` is computed over the payload below.

```text  theme={"system"}
<webhook-id>.<webhook-timestamp>.<payload>
```

Where:

* `<webhook-id>`: The value of the `webhook-id` header
* `<webhook-timestamp>`: The value of the `webhook-timestamp` header
* `<payload>`: The exact JSON body of the webhook request

You must parse the version and the signature before verifying. The `webhook-signature` header uses space-delimited signatures; check each signature until one matches.

Here's how you may verify the signature:

<CodeGroup>
  ```typescript TypeScript (Node.js) theme={"system"}
  import crypto from "crypto";

  function computeSignature(
    secret: string,
    webhookId: string,
    webhookTimestamp: string,
    body: string | Buffer
  ): string {
    const payload = `${webhookId}.${webhookTimestamp}.${body.toString()}`;
    const digest = crypto.createHmac("sha256", secret).update(payload).digest();
    return digest.toString("base64"); // standard Base64 with padding
  }

  function isValidSignature(
    webhookSignatureHeader: string,
    expectedSignature: string
  ): boolean {
    // Header may contain multiple space-delimited entries; each is "v1,<sig>"
    const signatures = webhookSignatureHeader.split(" ");

    for (const part of signatures) {
      const [, sig] = part.split(",", 2);
      if (
        crypto.timingSafeEqual(Buffer.from(sig), Buffer.from(expectedSignature))
      ) {
        return true;
      }
    }

    return false;
  }

  // Example usage in an Express endpoint
  import express from "express";

  const app = express();

  app.post(
    "/webhooks/parallel",
    express.raw({ type: "application/json" }),
    (req, res) => {
      const webhookId = req.headers["webhook-id"] as string;
      const webhookTimestamp = req.headers["webhook-timestamp"] as string;
      const webhookSignature = req.headers["webhook-signature"] as string;
      const secret = process.env.PARALLEL_WEBHOOK_SECRET!;

      const expectedSignature = computeSignature(
        secret,
        webhookId,
        webhookTimestamp,
        req.body
      );

      if (!isValidSignature(webhookSignature, expectedSignature)) {
        return res.status(401).send("Invalid signature");
      }

      // Parse and process the webhook payload
      const payload = JSON.parse(req.body.toString());
      console.log("Webhook received:", payload);

      // Process the task run status update
      if (payload.type === "task_run.status") {
        const taskRun = payload.data;
        console.log(`Task ${taskRun.run_id} status: ${taskRun.status}`);

        // Your business logic here
      }

      res.status(200).send("OK");
    }
  );
  ```

  ```typescript TypeScript (Web API / Cloudflare Workers) theme={"system"}
  // Example for environments without Node.js crypto module
  async function computeSignature(
    secret: string,
    webhookId: string,
    webhookTimestamp: string,
    body: string
  ): Promise<string> {
    const payload = `${webhookId}.${webhookTimestamp}.${body}`;
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      "raw",
      encoder.encode(secret),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );

    const signature = await crypto.subtle.sign(
      "HMAC",
      key,
      encoder.encode(payload)
    );

    // Convert to base64
    const base64 = btoa(String.fromCharCode(...new Uint8Array(signature)));
    return base64;
  }

  function isValidSignature(
    webhookSignatureHeader: string,
    expectedSignature: string
  ): boolean {
    const signatures = webhookSignatureHeader.split(" ");

    for (const part of signatures) {
      const [, sig] = part.split(",", 2);
      if (sig === expectedSignature) {
        return true;
      }
    }

    return false;
  }

  // Example Cloudflare Worker
  export default {
    async fetch(request: Request): Promise<Response> {
      if (request.method !== "POST") {
        return new Response("Method not allowed", { status: 405 });
      }

      const webhookId = request.headers.get("webhook-id")!;
      const webhookTimestamp = request.headers.get("webhook-timestamp")!;
      const webhookSignature = request.headers.get("webhook-signature")!;
      const secret = "your-webhook-secret";

      const body = await request.text();

      const expectedSignature = await computeSignature(
        secret,
        webhookId,
        webhookTimestamp,
        body
      );

      if (!isValidSignature(webhookSignature, expectedSignature)) {
        return new Response("Invalid signature", { status: 401 });
      }

      const payload = JSON.parse(body);
      console.log("Webhook received:", payload);

      return new Response("OK", { status: 200 });
    },
  };
  ```

  ```python Python theme={"system"}
  import base64, hashlib, hmac

  def compute_signature(secret: str, webhook_id: str, webhook_timestamp: str, body: bytes) -> str:
      payload = f"{webhook_id}.{webhook_timestamp}.{body.decode()}".encode()
      digest = hmac.new(secret.encode(), payload, hashlib.sha256).digest()
      return base64.b64encode(digest).decode()  # standard Base64 with padding

  def is_valid_signature(webhook_signature_header: str, expected_signature: str) -> bool:
      # Header may contain multiple space-delimited entries; each is "v1,<sig>"
      for part in webhook_signature_header.split():
          _, sig = part.split(",", 1)
          if hmac.compare_digest(sig, expected_signature):
              return True
      return False
  ```

  ```bash Bash theme={"system"}
  #!/bin/bash

  # Inputs: HEADER_SIGNATURE (e.g. "v1,BASE64..."), WEBHOOK_ID, WEBHOOK_TIMESTAMP, PAYLOAD (minified JSON), SECRET
  RECEIVED_SIGNATURE=$(printf "%s" "$HEADER_SIGNATURE" | cut -d',' -f2)
  TO_SIGN="$WEBHOOK_ID.$WEBHOOK_TIMESTAMP.$PAYLOAD"
  EXPECTED_SIGNATURE=$(printf "%s" "$TO_SIGN" | openssl dgst -sha256 -hmac "$SECRET" -binary | base64 | tr -d '\n')

  if [ "$EXPECTED_SIGNATURE" = "$RECEIVED_SIGNATURE" ]; then
    echo "✅ Signature verification successful"
  else
    echo "❌ Signature verification failed"
    exit 1
  fi
  ```
</CodeGroup>

### Retry Policy

Webhook delivery uses the following retry configuration:

* **Initial delay**: 5 seconds
* **Backoff strategy**: Exponential backoff (doubles per failed request)
* **Maximum retries**: Multiple attempts over 48 hours

After exhausting all retry attempts, webhook delivery for that event is terminated.

## Best Practices

Be sure to set up your webhook endpoint so that you:

### 1. Always Return 2xx Status

Your webhook endpoint should return a 2xx HTTP status code to acknowledge receipt. Any other status code will trigger retries.

### 2. Verify Signatures

Always verify HMAC signatures using your account webhook secret from <strong>Settings → Webhooks</strong> to ensure webhook authenticity. Ensure that you are calculating signatures using the proper process as shown above.

### 3. Handle Duplicates

Although not common, duplicate events may be sent to the configured webhook URL.
Ensure your webhook handler can detect and safely ignore duplicate events.

### 4. Process Asynchronously

Process webhook events asynchronously to avoid timeouts and ensure quick response times.
